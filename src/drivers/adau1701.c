#include <zephyr/drivers/i2c.h>

#define ADAU1701_I2C_ADDRESS 0x34 // I2C address for ADAU1701

void init_adau1701(void) {
    static const struct i2c_dt_spec adau_1701_i2c = I2C_DT_SPEC_GET();
};

// Function prototypes
void DSP_HARD_RESET();

/**
 * This setup function is responsible for initializing hardware libraries.
 */
void setup() {
    delay(1000);              // 1 second startup delay
    Serial.begin(115200);    // Initialize the USB serial port for debug

    // Initialize I2C library
    pinMode(10, OUTPUT);         // Drive ADDR0 low for Sigma300/350; pinMode defaults to logic low
    pinMode(11, OUTPUT);         // Drive ADDR0 low for Sigma300/350; pinMode defaults to logic low
    pinMode(12, INPUT);          // Set the SPI MISO pin high-impedance to avoid contention with I2C
    pinMode(13, INPUT);          // Set the SPI SCLK pin high-impedance to avoid contention with I2C
    Wire.begin();                // Initialize I2C library
    Wire.setClock(I2C_SPEED);    // Set I2C SCL frequency based on the value in USER_SETTINGS.h
}    // End of setup

void loop() {
    // Drive Pin 6 of the USBi connector low to reset the DSP and SPI toggle if necessary.
    DSP_HARD_RESET();

    // default_download_IC_1, generated by SigmaStudio, will download the SigmaStudio program and start up the
    // DSP. It relies on a proper SPI or I2C implementation in SIGMASTUDIOFW.cpp, which must be tailored to
    // the individual processor. and assigning pins correctly in USER_SETTINGS.h.
    default_download_IC_1();

	
    // Wait 10 seconds, then re-program the DSP again
    delay(10000);
}    // End of loop

void DSP_HARD_RESET() {
    pinMode(DSP_RESET_PIN, OUTPUT);
    digitalWrite(DSP_RESET_PIN, LOW);
    delay(10);
    digitalWrite(DSP_RESET_PIN, HIGH);
    // This delay accounts for ADM811T reset generator hold time on ADAU1467 eval board, adjust
    // as needed
    delay(560);
}