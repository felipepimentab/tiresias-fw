#include <zephyr/drivers/i2c.h>
#include "../SigmaStudioFiles/adau_1701_IC_1_PARAM.h"
#include "../SigmaStudioFiles/adau_1701_IC_1_REG.h"
#include "../SigmaStudioFiles/adau_1701_IC_1.h"

#define I2C_NODE DT_NODELABEL(adau_1701)

void adau1701_init() {
	static const struct i2c_dt_spec dev_i2c = I2C_DT_SPEC_GET(I2C_NODE);
	if (!device_is_ready(dev_i2c.bus)) {
		printk("I2C bus %s is not ready!\n\r",dev_i2c.bus->name);
		return -1;
	}

    // default_download_IC_1, generated by SigmaStudio, will download the SigmaStudio program and start up the
    // DSP. It relies on a proper SPI or I2C implementation in SIGMASTUDIOFW.cpp, which must be tailored to
    // the individual processor. and assigning pins correctly in USER_SETTINGS.h.
    default_download_IC_1();
}

// Examples:

void i2c_write_example() {
    uint8_t config[2] = {0x03,0x8C};
    ret = i2c_write_dt(&dev_i2c, config, sizeof(config));
    if(ret != 0){
        printk("Failed to write to I2C device address %x at reg. %x \n\r", dev_i2c.addr,config[0]);
    }
}

void i2c_read_example() {
    uint8_t data;
    ret = i2c_read_dt(&dev_i2c, &data, sizeof(data));
    if(ret != 0){
        printk("Failed to read from I2C device address %x at Reg. %x \n\r", dev_i2c.addr,config[0]);
    }
}